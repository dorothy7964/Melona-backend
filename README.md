# 올 때 메로나

소액 대행 서비스 프로젝트 입니다. <br/><br/>
[frontend Github 바로가기](https://github.com/dorothy7964/melona_frontend "frontend Github 바로가기") <br/>
[app Github 바로가기](https://github.com/dorothy7964/melona-app "app Github 바로가기")

<br/><br/>

### 주요 기능

1. 비밀번호 암호화
2. 로그인 시 토큰 인증 및 해석
3. 임시 비밀번호 이메일로 받기
4. AWS S3를 사용하여 사진 저장

<br/><br/>

### Backend Stack

- NodeJS
- Prisma
- GraphQL

<br/><br/>

# Install

## nodemon

<!-- Install Code -->

```js
$ yarn add nodemon -D
```

nodemon 은 파일을 저장할 때마다 실행을 새로 해주는 도구 입니다. <br/>
서버를 껐다가 켤 필요가 없습니다. <br/>

<br/><br/>

## @babel-cli

<!-- Install Code -->

```js
$ yarn add @babel-cli
```

babel은 es6코드를 es5로 바꿔주는 도구 입니다. <br/>
아직 지원되지 않는 곳들이 있어서 못생긴 코드로 바꿔줘야 합니다. <br/>

<br/><br/>

## @babel/node

<!-- Install Code -->

```js
$ yarn add @babel/node
```

요약 : 콘솔에서 JS 파일을 실행 <br />
babel-node는 Node.js CLI와 정확히 동일하게 작동하는 CLI로, <br />
실행하기 전에 Babel 사전 설정 및 플러그인으로 컴파일할 수 있는 부가적인 이점이 있습니다. <br />

<br/><br/>

## @babel/preset-env

<!-- Install Code -->

```js
$ yarn add @babel/preset-env
```

요약 : 코드 업데이트 <br />
ECMAScript5+ 버전 호환성을 위하여 정의된 플러그인의 집합 입니다. <br/>
작성한 코드가 괜찮은지 변환되어야 하는지 판단 해줍니다. <br />
문법에 대해 세부 작업을 할 필요 없이 최신 자바스크립트 문법을 사용할 수 있도록 해줍니다. <br />

<br/><br/>

## @babel/core

<!-- Install Code -->

```js
$ yarn add @babel/core
```

Babel을 사용하기 위한 플러그인 (babel.config.js) 입니다.

<br/><br/>

## morgan

<!-- Install Code -->

```js
$ yarn add morgan
```

morgan 이라는 미들웨어를 추가하고 logger(로깅 전문 모듈) 입니다.

<br/><br/>

## dotenv

<!-- Install Code -->

```js
$ yarn add dotenv
```

prisma 를 시작하지 전 dotenv 설치 합니다. <br/>
서버를 먼저 세우고, 그 다음에 prisma 를 서버 코드에 추가 합니다.

<br/><br/>

## graphql-yoga

<!-- Install Code -->

```js
$ yarn add graphql-yoga
```

요약 : create-react-app의 graqlQL 버전 <br/>
의존성 모듈(dependency)들을 설치 합니다. <br/>
graphql-yoga를 사용하기 때문에 express는 필요 없습니다. <br/>
현재 apollo 업데이트로 서버를 사용할 수 있고 셋업도 쉬워졌다.

<br/><br/>

## graphql-tools

<!-- Install Code -->

```js
$ yarn add graphql-tools
```

graphql 파일 분리 하려면 필요 합니다.

<br/><br/>

## prisma-client-lib

<!-- Install Code -->

```js
$ yarn add prisma-client-lib
```

Terminal 에서 prisma 콘솔을 확인 할 수 있습니다. <br/>
prisma 와 정보를 주고 받습니다.

### 테스트 해보기 (prisma-client-lib)

<!-- Example Code -->

```js
import { prisma } from "../../../../generated/prisma-client";

export default {
  Query: {
    sayHello: async () => {
      console.log(await prisma.users()); // console.log
      return "Hello";
    }
  }
};
```

<br/>

**실행**

```js
$ yarn dev
```

<br/><br/>

## merge-graphql-schemas

<!-- Install Code -->

```js
$ yarn add merge-graphql-schemas
```

graphql 파일 분리 하려면 필요 합니다.

<br/><br/>

<!--ㅇㅇㅇㅇㅇㅇㅇㅇ -->

## 만약 babel/cli -D 로 설치 했을 경우 제거해주기

<!-- Install Code -->

```js
$ yarn remove babel-cli
$ yarn global remove babel-cli
```

[오류발생] babel/cli -D 로 설치 했을 경우 최신 버전 @babel/clli 를 설치해야 합니다.

<br/><br/>

# 파일 생성

### nodemon.json 파일 생성

<!-- Example Code -->

```js
{
    "ext": "js graphql"
}
```

이 파일에 ext 라는 걸 추가 합니다. <br/>
nodemon이 감시해야 할 파일의 확장자들을 지정할 수 있습니다.

<br/><br/>

### .gitignore 파일 생성

<!-- Example Code -->

```js
{
// ~/wam-prj/prismagram/.gitignore

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next
generated
build
}
```

업로드 제외할 것들 넣어습니다.

<br/><br/>

### .env 파일 생성

<!-- Example Code -->

```js
PORT = 4000;
```

### .babelrc 파일 생성

<!-- Example Code -->

```js
{
    "presets": ["@babel/preset-env"]
}
```

babelrc 파일에 presets 작성하기 <br/>
가장 최신의 프리셋인 @babel/preset-env 를 사용 합니다.

<br/><br/>

### env.js 파일 생성

<!-- Example Code -->

```js
import dotenv from "dotenv";
dotenv.config();
```

<br/><br/>

### schema 파일 생성

<!-- Example Code -->

```js
import path from "path";

import { makeExecutableSchema } from "graphql-tools";
import { fileLoader, mergeResolvers, mergeTypes } from "merge-graphql-schemas";

const allTypes = fileLoader(path.join(__dirname, "/api/**/*.graphql"));
const allResolvers = fileLoader(path.join(__dirname, "/api/**/*.js"));

const schema = makeExecutableSchema({
  typeDefs: mergeTypes(allTypes),
  resolvers: mergeResolvers(allResolvers)
});

export default schema;
```

<br/>

**schema 설명**

- **fileLoader** : 인자로 path를 받아 파일을 load해줍니다.
- **path.join** : 해당 경로의 파일들을 가져옵니다.
- **makeExecutabelSchema** : type, resolver를 schema 형태로 만들어 줍니다.

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/src/schema.js

import path from "path"; // 설명[3-1]

// 설명[1]
import { makeExecutableSchema } from "graphql-tools";
import { fileLoader, mergeResolvers, mergeTypes } from "merge-graphql-schemas";

// 설명[3]
const allTypes = fileLoader(path.join(__dirname, "/api/**/*.graphql"));
const allResolvers = fileLoader(path.join(__dirname, "/api/**/*.js"));

// 설명[2]
const schema = makeExecutableSchema({
  typeDefs: mergeTypes(allTypes),
  resolvers: mergeResolvers(allResolvers)
});

// 설명[4]
export default schema;
```

**설명[1]**

<!-- Example Code -->

```js
import { makeExecutableSchema } from "graphql-tools";
import { fileLoader, mergeResolvers, mergeTypes } from "merge-graphql-schemas";
```

graphql-tools, merge-graphql-schemas 설치해 준 것들을 불러와 줍니다.

<br/>

**설명[2]**

<!-- Example Code -->

```js
const schema = makeExecutableSchema({
  typeDefs: mergeTypes(allTypes),
  resolvers: mergeResolvers(allResolvers)
});
```

schema 파일에 우선 모든 type 들을 추가 합니다. <br/>
makeExecutableSchemas 함수의 인자로 typeDefs 와 resolvers 를 입력해주면 됩니다. <br/>
allTypes 라는 변수를 만들고 이 변수는 fileLoader 함수의 결과물 입니다.

 <br/>

**설명[3]**

[참고] api 폴더 밑에는 resolver 가 아닌 js 파일을 두면 안됩니다! <br/>
api 폴더 밑에는 resolver 나 graphql 아닌 파일을 두지 않기! <br/>

<!-- Example Code -->

```js
const allTypes = fileLoader(path.join(__dirname, "/api/**/*.graphql"));
const allResolvers = fileLoader(path.join(__dirname, "/api/**/*.js"));
```

fileLoader 함수의 인자로 path.join(\_\_dirname, "/api/**/\*.graphql") 을 입력
** 는 모든 폴더고, \*.graphql 은 모든 .graphql 파일 입니다. <br/>

다시말해 api 폴더 밑의 모든 폴더에 속해있고 .graphql 로 끝나는 모든 파일들을 가져오는 것 입니다. <br/>

같은 방식으로 allResolvers 를 만들기 <br/>
이렇게 하면 아주 긴 파일경로를 입력하게 되는 것 입니다. <br/>
api 폴더 밑에 모든 폴더의 파일들 중 .js 로 끝나는 파일들을 입력하기

<br/>

```js
import path from "path"; // 설명[3-1]
```

fileLoader 함수의 인자로 파일의 경로를 입력 해야 합니다. <br/>
path 모듈을 import 하기

<br/>

**설명[4]**

<!-- Example Code -->

```js
export default schema;
```

마지막으로 내보내주면 됩니다.

<br/><br/>

### package.json

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/package.json

{
  "name": "prismagram",
  "version": "1.0.0",
  "description": "Instragram clone with Express + Prisma + React and React Native",
  //"main": "index.js", 이부분은 필요없으므로 이 줄 삭제하기
  "license": "MIT",
  "dependencies": {
    "graphql-yoga": "^1.18.2"
  }
}
```

**scripts 추가하기**

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/package.json

"scripts": {
	  "dev": "nodemon --exec babel-node src/server.js",
	  "deploy": "prisma deploy",
	  "generate": "prisma generate",
	  "prisma": "yarn run deploy && yarn run generate",
	  "prebuild": "yarn run generate",
	  "build": "babel src -d build",
	  "postbuild": "npx copy src/api/**/**.graphql ./build/api/",
	  "start": "node build/server.js"
}
```

**실행**

<!-- Example Code -->

```js
$ yarn dev
```

<br/><br/>

# Datamodel & Migrations 배포

<!-- Example Code -->

```js
$ prisma deploy
```

package.json 에 `"prisma": "yarn run deploy && yarn run generate",` 작성하고 아래 처럼 배포해도 됩니다.

<!-- Example Code -->

```js
$ yarn prisma
```

<br/><br/>

# 비밀번호 암호화 (bcrypt 라이브러리)

### 명령프롬프트, powershell 관리자 권한으로 실행 후 설치

<!-- Install Code -->

```js
$ yarn global add windows-build-tools
```

윈도우에서 필수인 c, c++ 관련된 것들과 파이썬같은 것을 설치해서 다른 언어를 사용하는 라이브러리르 지원할 수 있게 해줍니다.

<br/>

### 터미널에서 설치

<!-- Install Code -->

```js
$ yarn global add node-pre-gyp
$ yarn add bcrypt@3.0.6
$ yarn add @types/bcrypt --dev
```

<br/>

### 사용법

**async (recommended)**

<!-- Example Code -->

```js
const bcrypt = require("bcrypt");
const saltRounds = 10;
const myPlaintextPassword = "s0//P4$$w0rD";
const someOtherPlaintextPassword = "not_bacon";
```

saltRounds = salt 를 만들 때의 10자리인 Salt 를 만들어 달라는 것 입니다.

<br/>

**To hash a password: Technique 1**

<!-- Example Code -->

```js
bcrypt.genSalt(saltRounds, function(err, salt) {
  bcrypt.hash(myPlaintextPassword, salt, function(err, hash) {
    // Store hash in your password DB.
  });
});
```

별도의 함수 호출에서 Salt 및 hash 생성하기 <br/>
Salt 를 이용해서 비밀번호 암호화 하기

<br/>

### 회원가입 시 비밀번호 암호화

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/src/passwordMatch.js

import bcrypt from "bcrypt";

export const hashPassword = (password, saltRounds) =>
  bcrypt.hash(password, saltRounds);
```

**bcrypt.hash 설명**

<!-- Example Code -->

```js
// 참고
const hash = bcrypt.hashSync(myPlaintextPassword, saltRounds);
bcrypt.hash(password, 10);
```

첫 번째 인자 myPlaintextPassword 에는 비밀번호를 보내주고 <br/>
두 번째 인자 saltRounds 에는 salt 를 만들 때의 5자리인 Salt 를 만들어 달라는 것 입니다.

<br/>

**계정 추가**

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/src/api/User/createAccount/createAccount.graphql

type Mutation {
    createAccount(
        email: String!
        userName: String!
        password: String!
        avatar: String
    ): Boolean!
}
// 아래는 만약 쿼리가 없다고 오류 뜰 경우 가짜 쿼리 만들어주기
type Query {
  createAccount: String!
}
```

<br/>

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/src/api/User/createAccount/createAccount.js

import { prisma } from "../../../../generated/prisma-client";
import { hashPassword } from "../../../passwordMatch";

export default {
  Mutation: {
    createAccount: async (_, args) => {
      const { email, userName, password, avatar } = args;

      const ExistUserName = await prisma.$exists.user({
        userName
      });
      const ExistEmail = await prisma.$exists.user({
        email
      });

      if (ExistUserName) {
        throw Error("이미 있는 이름 입니다.");
      } else if (ExistEmail) {
        throw Error("이미 있는 이메일 입니다.");
      }

      try {
        const hsPassword = await hashPassword(password, 5);
        await prisma.createUser({
          email,
          userName,
          password: hsPassword,
          avatar
        });
        return true;
      } catch (e) {
        console.log(e);
        return false;
      }
    }
  }
};
```

**설명**

<!-- Example Code -->

```js
import { hashPassword } from "../../../passwordMatch";

const { email, userName, password, avatar } = args;
const hsPassword = await hashPassword(password, 5);
```

아래 와 같이 `passwordMatch.js` 에서 hashPassword 함수를 불러오게 되면 <br/>
첫 번째 인자 - 비밀번호, 두 번째 인자 - Salt 글자 수 를 넣게되면 보낸 비밀번호가 암호화해서 돌려주게 됩니다. <br/>

<br/>

**암호화 된 비밀번호를 hsPassword 변수 넣기**

<!-- Example Code -->

```js
// passwordMatch.js
import bcrypt from "bcrypt";

export const hashPassword = (password, saltRounds) =>
  bcrypt.hash(password, saltRounds);
```

<br/>

**암호화 된 비밀번호 업데이트**

<!-- Example Code -->

```js
await prisma.createUser({
  email,
  userName,
  password: hsPassword,
  avatar
});
```

<br/><br/>

# 토큰 인증기능 쉽게 연결 (passport-jwt 라이브러리)

로그인 시 사용자의 로그인 비밀번호와 입력된 비밀번호 값이 같다면 토큰을 리턴해주기

<br/>

### passportjs

인증 토큰을 위해 passportjs 를 사용하기 <br/>
passportjs 는 모든 인증 기능을 아주 쉽게 만들어 줍니다. <br/>
passport 를 설치하고 설정만 해주면 모든 인증 기능을 사용할 수 있습니다.

<br/>

### passport-jwt 설치

<!-- Install Code -->

```js
yarn add passport-jwt passport
```

<br/>

### passport 연결하기

passport 는 인증 관련 모든 일을 합니다. <br/>
토큰에서 정보를 가져와서 (express 의) request 에 붙여 줍니다. <br/>
토큰을 가져와서 해독한 후에 사용자 객체를 request에 추가 해줍니다. <br/>

다시말해 jwt 토큰이나 쿠키에서 정보를 가져와서 사용자 정보에 저장 합니다. <br/>
이 모든 것을 자동으로 해주는 장점이 있습니다.

<br/>

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/passport.js

import passport from "passport";
import { Strategy, ExtractJwt } from "passport-jwt";
import { prisma } from "../generated/prisma-client";

const jwtOptions = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: process.env.JWT_SECRET
};

const verifyUser = async (payload, done) => {
  try {
    const user = await prisma.user({ id: payload.id });
    if (user !== null) {
      return done(null, user);
    } else {
      return done(null, false);
    }
  } catch (error) {
    return done(error, false);
  }
};

export const authenticateJwt = (req, res, next) =>
  passport.authenticate("jwt", { sessions: false }, (error, user) => {
    if (user) {
      req.user = user;
    }
    next();
  })(req, res, next);

passport.use(new Strategy(jwtOptions, verifyUser));
passport.initialize();
```

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/.env

JWT_SECRET = "랜덤 문자열 넣어주면 된다.";
```

<br/>

### 토큰 해석, authenticateJwt 함수 실행

토큰을 해석하려면 passport 가 필요 합니다.

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/server.js

import "./env";
import { GraphQLServer } from "graphql-yoga";
import logger from "morgan";
import schema from "./schema";
import "./passport";
import { authenticateJwt } from "./passport";

const PORT = process.env.PORT || 4000;

console.log(process.env.PORT);

// [2]
const server = new GraphQLServer({
  schema,
  context: ({ request }) => ({ request })
});

server.express.use(logger("dev"));
server.express.use(authenticateJwt);

server.start({ port: PORT }, () =>
  console.log(`✔ Server running on http://localhost:${PORT}`)
);
```

**passport 설명**

<!-- Example Code -->

```js
import "./passport";
```

passport.js 파일에 passport 모듈이 import 되어 있습니다. <br/>
server.js 에서는 passport.js 파일에서 무언가를 받아서 사용할 필요가 없습니다.

<br/>

**authenticateJwt 설명**

<!-- Example Code -->

```js
import { authenticateJwt } from "./passport";

server.express.use(authenticateJwt);
```

authenticateJwt 를 실행하게 해줍니다.

<br/>

모든 resolver 에 정보를 전달하기 위해 context 를 사용 할 수있다.

<!-- Example Code -->

```js
const server = new GraphQLServer({
  schema,
  context: ({ request }) => ({ request })
});
```

resolver 이 알 수 있도록 전달해 줍니다다. <br/>
context 는 resolver 사이에서 정보를 공유할 때 사용한다.

<br/><br/>

# jwt를 생성하는 방법 (jsonwebtoken 라이브러리)

`passport.js` 에서 작업 한 jwt 를 가져와서 해석하고 확인하는 작업 입니다.

### jsonwebtoken 설치

<!-- Install Code -->

```js
$ yarn add jsonwebtoken
```

`jwt.sign(payload, secretOrPrivateKey, [options, callback])` <br/>
sign 함수를 실행할 때 payload 를 입력 해야 합니다. <br/>
우리는 payload 위치에 사용자의 id 를 입력 합니다. <br/>
그리고 secret key 를 입력 해야 합니다.

<br/>

**사용법 적용**

<!-- Example Code -->

```js
// jwt.sign(payload, secretOrPrivateKey, [options, callback])
jwt.sign({ id }, process.env.JWT_SECRET);
```

<br/>

### generateToken 파일 생성

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/generateToken.js

import jwt from "jsonwebtoken";

export const generateToken = (id) => jwt.sign({ id }, process.env.JWT_SECRET);
```

<br/><br/>

# 비밀번호 확인하기 (jsonwebtoken 사용)

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/passwordMatch.js

import bcrypt from "bcrypt";

export const hashPassword = (password, saltRounds) =>
  bcrypt.hash(password, saltRounds);
export const passwordMatch = (password, userPassword) =>
  bcrypt.compare(password, userPassword);
```

<br/>

### 로그인한 유저 토큰 생성

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/api/User/confirmPassword/confirmPassword.graphql

type Mutation {
    confirmPassword(email: String!, password: String!): String!
}
```

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/api/User/confirmPassword/confirmPassword.js

import { prisma } from "../../../../generated/prisma-client";
import { generateToken } from "../../../generateToken";
import { passwordMatch } from "../../../passwordMatch";

export default {
  Mutation: {
    confirmPassword: async (_, args) => {
      const { email, password } = args;
      const user = await prisma.user({ email });
      if (!user) {
        throw Error("유저가 없습니다.");
      }
      const passwordConfirm = await passwordMatch(password, user.password);
      if (!passwordConfirm) {
        throw Error("비밀번호가 틀립니다.");
      }

      return generateToken(user.id);
    }
  }
};
```

### 설명

**email 과 password 받기**

<!-- Example Code -->

```js
const { email, password } = args;
const user = await prisma.user({ email });
```

받은 email 로 user 를 prisma 에서 찾은 후 user 변수에 넣기

<br/>

**비밀번호 확인**

<!-- Example Code -->

```js
import { passwordMatch } from "../../../passwordMatch";

const passwordConfirm = await passwordMatch(password, user.password);
```

아래 와 같이 `passwordMatch.js` 에서 passwordMatch 함수를 불러오게 되면 첫 번째 인자 - 유저가 적은 비밀번호, 두 번째 인자 - prisma에 있는 유저 비밀번호 를 넘겨주게 됩니다. <br/>
passwordMatch 함수에 Boolean 값으로 비밀번호를 확인 해줍니다. <br/>
Boolean 값은 passwordConfirm 변수에 넣으면 됩니다.

<!-- Example Code -->

```js
// passwordMatch.js
import bcrypt from "bcrypt";

export const passwordMatch = (password, userPassword) =>
  bcrypt.compare(password, userPassword);
```

<br/>

**토큰 생성**

<!-- Example Code -->

```js
import { generateToken } from "../../../generateToken";

return generateToken(user.id);
```

아래 와 같이 generateToken.js 에서 generateToken 함수를 불러오게 되면 토큰을 생성 할 수 있다.

<!-- Example Code -->

```js
// generateToken.js
import jwt from "jsonwebtoken";

export const generateToken = (id) => jwt.sign({ id }, process.env.JWT_SECRET);
```

<br/><br/>

# middleware

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/middlewares.js

export const isAuthenticated = (request) => {
  if (!request.user) {
    throw Error("You need to log in to perform this action");
  }
  return;
};
```

express middeleware 는 아니고 graphQl middleware 랑 같은 것 입니다. <br/>
이건 API 밖에 있어야 합니다.

<br/>

<!-- Example Code -->

```js
// ~/wam-prj/prismagram/src/server.js

import "./env";
import { GraphQLServer } from "graphql-yoga";
import logger from "morgan";
import schema from "./schema";
import "./passport";
import { authenticateJwt } from "./passport";
import { isAuthenticated } from "./middlewares";

const PORT = process.env.PORT || 4000;

const server = new GraphQLServer({
  schema,
  context: ({ request }) => ({ request, isAuthenticated })
});

server.express.use(logger("dev"));
server.express.use(authenticateJwt);
server.start({ port: PORT }, () =>
  console.log(`✔ Server running on http://localhost:${PORT}`)
);
```

만약 server.js에 isAuthenticated 를 추가하지 않는다면 각 파일마다 import 해줘야 합니다.

<br/><br/>

# 임시 비밀번호 보내기 (Nodemailer 사용)

### 이메일을 보내기 위해 nodemailer 설치

<!-- Install Code -->

```js
$ yarn add nodemailer
$ yarn add nodemailer-sendgrid-transport
```

<br/>

### sendgrid 사용법

<!-- Example Code -->

```js
// sending-email-nodemailer-sendgrid

var nodemailer = require('nodemailer');
var sgTransport = require('nodemailer-sendgrid-transport'); // 설치하기

// options
var options = {
  auth: {
    api_user: 'SENDGRID_USERNAME',
    api_key: 'SENDGRID_PASSWORD'
  }
}

var client = nodemailer.createTransport(sgTransport(options));

var email = {
  from: 'awesome@bar.com',
  to: 'mr.walrus@foo.com',
  subject: 'Hello',
  text: 'Hello world',
  html: '<b>Hello world</b>'
};

client.sendMail(email, function(err, info){
    if (err ){
      console.log(error);
    }
    else {
      console.log('Message sent: ' + info.response);
    }
});
To continue using Nodemailer with SMTP, just set your service to ‘SendGrid’ as shown below.

var client = nodemailer.createTransport({
  service: 'SendGrid',
  auth: {
    user: 'SENDGRID_USERNAME',
    pass: 'SENDGRID_PASSWORD'
  }
});

// See above
```

<br/>

### Nodemailer 사용

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/.env

SENDGRID_USERNAME = "sendgrid 사이트의 UserName 넣으면 된다.";
SENDGRID_PASSWORD = "sendgrid 사이트의 Password 넣으면 된다.";
```

<br/>

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/utils.js

import { adjectives, nouns } from "./words";
import nodemailer from "nodemailer";
import sgTransport from "nodemailer-sendgrid-transport";

export const generatorSecret = () => {
  const randomNumber = Math.floor(Math.random() * adjectives.length);
  return `${adjectives[randomNumber]}${nouns[randomNumber]}`;
};

const sendMail = (email) => {
  const options = {
    auth: {
      api_user: process.env.SENDGRID_USERNAME,
      api_key: process.env.SENDGRID_PASSWORD
    }
  };
  const client = nodemailer.createTransport(sgTransport(options));
  return client.sendMail(email);
};

export const sendSecretMail = (address, secret) => {
  const email = {
    from: "admin@melona.com",
    to: address,
    subject: "🔒 Login Secret for Melona 🔒",
    html: `Hello! Your login secret is <strong>${secret}</strong>.<br/>Copy paste on the app/website to log in`
  };
  return sendMail(email);
};
```

### sendMail 설명

**계정 정보 접근 후 옵션 만들기**

<!-- Example Code -->

```js
console.log(process.env.SENDGRID_USERNAME, process.env.SENDGRID_PASSWORD);

const sendMail = (email) => {
  const options = {
    auth: {
      api_user: process.env.SENDGRID_USERNAME,
      api_key: process.env.SENDGRID_PASSWORD
    }
  };
};
```

<br/>

**client.sendMail 실행**

<!-- Example Code -->

```js
import nodemailer from "nodemailer";
import sgTransport from "nodemailer-sendgrid-transport";

const sendMail = (email) => {
  const options = {
    auth: {
      api_user: process.env.SENDGRID_USERNAME,
      api_key: process.env.SENDGRID_PASSWORD
    }
  };
  const client = nodemailer.createTransport(sgTransport(options));
  return client.sendMail(email);
};
```

nodemailer.createTransport(sgTransport(options)) 를 실행한 결과물을 client 에 할당하기

`sgTransport` 몇몇 기본 값들로 transport 라는 걸 만들고 그걸 sendMail 을 요청하면 끝 입니다. <br/>

transport 가 대신 알아서 해줍니다.

<br/>

**sendSecretMail 함수에서 sendMail 함수 실행**

<!-- Example Code -->

```js
export const sendSecretMail = (address, secret) => {
  const email = {
    from: "melona@melona.com",
    to: address,
    subject: "🔒 Login Secret for Melona 🔒",
    html: `Hello! Your login secret is <strong>${secret}</strong>.<br/>Copy paste on the app/website to log in`
  };
  return sendMail(email);
};
```

sendSecretMail 를 사용하고 sendMail 은 외부 에서 사용 하지 않으니 export 하지 않아도 됩니다.

<br/><br/>

# AWS S3를 사용하여 사진 저장

### Access key 백엔드 env 파일에 넣어주기

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/.env

AWS_KEY = "Access key 넣어주면 된다.";
AWS_SECRET = "Secret access key 넣어주면 된다.";
```

버킷 생성 후 AWS_KEY와 AWS_SECRET 넣어주기

<br/>

### multer-s3 설치

<!-- Install Code -->

```js
$ yarn add multer-s3
$ yarn add aws-sdk
```

<br/>

### multer-s3 적용

<!-- Example Code -->

```js
// ~/wam-prj/melona-backend/src/upload.js

import multer from "multer";
import multerS3 from "multer-s3";
import aws from "aws-sdk";

const s3 = new aws.S3({
  accessKeyId: process.env.AWS_KEY, // 생성한 s3의 accesskey
  secretAccessKey: process.env.AWS_SECRET, // 생성한 s3의 secret key
  region: "ap-northeast-2" // 지역설정
});

const upload = multer({
  storage: multerS3({
    s3,
    acl: "public-read", // 업로드 된 데이터를 URL로 읽을 때 설정하는 값입니다. 업로드만 한다면 필요없습니다.
    bucket: "melona.cf", // s3 생성시 버킷명
    metadata: function(req, file, cb) {
      cb(null, { fieldName: file.fieldname }); // 파일 메타정보를 저장합니다.
    },
    key: function(req, file, cb) {
      cb(null, Date.now().toString());
    }
  })
});
export const uploadMiddleware = upload.single("file");

export const uploadController = (req, res) => {
  const {
    file: { location }
  } = req;
  res.json({ location });
};
```

<br/><br/>
